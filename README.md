Student Name: Vishakh Thekkiniyath Varghese
Student ID: C0913256

1. The Array Artifact: In this task, I created the ArtifactVault class, where the user can choose the array size to store artifacts. ArtifactVault class manages an array of artifacts, ensuring it doesn't exceed its capacity by tracking the number of artifacts with a size variable. The array is kept sorted by artifact age using Arrays.sort() after each insertion or removal. To remove an artifact, the class searches for it, replaces it with the last artifact, sets the last slot to null, decrements the size, and sorts the array again. It implements both linear and binary search methods for finding artifacts. The design assumes a fixed capacity provided by the user at runtime and represents artifacts as strings. The main method offers a menu-driven interface for user interaction. To run the code, save it as ArtifactVault.java, compile it with javac ArtifactVault.java, and execute it with java ArtifactVault.

2. The Linked List Labyrinth: In this task, I created the LabyrinthPath class, which uses a singly linked list to manage a path of locations. The class includes methods to add a new location, remove the last visited location, check if the path contains a loop (trap), and print the entire path. The Node class represents each location in the path. The addLocation method appends a new location to the end of the list, while the removeLastLocation method removes the last location by traversing the list. The containsLoop method uses the Floydâ€™s Cycle-Finding Algorithm to detect loops. The printPath method traverses the list and prints each location. I assumed the path is represented as a singly linked list and locations are strings. The list can grow dynamically as new locations are added. I chose a singly linked list for efficient insertion at the end and used two pointers in the containsLoop method to detect loops efficiently. To run the code, save it as LabyrinthPath.java, compile it with javac LabyrinthPath.java, and execute it with java LabyrinthPath.
   
3. The Stack of Ancient Texts: In this task, I created the ScrollStack class, which uses a stack to manage scrolls. The class includes methods to push a new scroll onto the stack, pop the top scroll off the stack, peek at the top scroll without removing it, and check if a specific scroll title exists in the stack. The pushScroll method adds a scroll to the stack, while the popScroll method removes the top scroll. The peekScroll method allows viewing the top scroll without removing it, and the containsScroll method checks if a scroll is in the stack. I assumed the stack would be used to manage scrolls represented as strings. The main method provides a menu-driven interface for user interaction. To run the code, save it as ScrollStack.java, compile it with javac ScrollStack.java, and execute it with java ScrollStack.
   
4. The Queue of Explorers: In this task, I created the ExplorerQueue class, which uses a circular queue to manage explorers. The class includes methods to enqueue new explorers, dequeue explorers when they enter the temple, display the next explorer in line, and check if the queue is full or empty. The enqueue method adds an explorer to the queue, while the dequeue method removes the front explorer. The peek method allows viewing the next explorer without removing them, and the isFull and isEmpty methods check the queue's status. I assumed the queue would have a fixed capacity provided by the user at runtime and represent explorers as strings. The main method provides a menu-driven interface for user interaction. To run the code, save it as ExplorerQueue.java, compile it with javac ExplorerQueue.java, and execute it with java ExplorerQueue.
   
5. The Binary Tree of Clues: In this task, I created the ClueTree class, which represents a binary tree of clues. The class includes methods to insert a new clue, perform in-order, pre-order, and post-order traversals, find a specific clue, and count the total number of clues in the tree. The Node class represents each clue in the tree. The insertClue method adds a new clue to the tree, while the traversal methods (inOrder, preOrder, postOrder) allow different ways to traverse the tree. The findClue method searches for a specific clue, and the countClues method counts the total number of clues. I assumed the tree would be used to manage clues represented as strings. The main method provides a menu-driven interface for user interaction. To run the code, save it as ClueTree.java, compile it with javac ClueTree.java, and execute it with java ClueTree.
   

